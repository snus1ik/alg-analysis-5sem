\documentclass{bmstu}
\usepackage{multirow}
\usepackage{threeparttable}
\usepackage[clean]{svg}
\usepackage{adjustbox}

\include{preamble}

\bibliography{biblio}

\begin{document}
\renewcommand{\thelstlisting}{\arabic{lstlisting}}
\lstset{%
	language=python,
	basicstyle=\small\sffamily,
	numbers=left,
	stepnumber=1,
	numbersep=5pt,
	frame=single,
	tabsize=4,
	captionpos=t,
	breaklines=true,
	breakatwhitespace=true,
	escapeinside={\#*}{*)},
	backgroundcolor=\color{white},
}

\begin{titlepage}
	\newgeometry{pdftex, left=2cm, right=2cm, top=2.5cm, bottom=2.5cm}
	\fontsize{12pt}{12pt}\selectfont
	\noindent \begin{minipage}{0.15\textwidth}
		\includegraphics[width=\linewidth]{img/b_logo.jpg}
	\end{minipage}
	\noindent\begin{minipage}{0.9\textwidth}\centering
		\textbf{Министерство науки и высшего образования Российской Федерации}\\
		\textbf{Федеральное государственное бюджетное образовательное учреждение высшего образования}\\
		\textbf{«Московский государственный технический университет имени Н. Э.~Баумана}\\
		\textbf{(национальный исследовательский университет)»}\\
		\textbf{(МГТУ им. Н. Э.~Баумана)}
	\end{minipage}

	\noindent\rule{18cm}{3pt}
	\newline\newline
	\noindent ФАКУЛЬТЕТ $\underline{\text{«Информатика и системы управления»~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$ \newline\newline
	\noindent КАФЕДРА $\underline{\text{«Программное обеспечение ЭВМ и информационные технологии»~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline\newline\newline\newline\newline\newline


	\begin{center}
		\noindent\begin{minipage}{1.3\textwidth}\centering
		\Large\textbf{   ~~~ Лабораторная работа №3}\newline
		\textbf{по дисциплине <<Анализ Алгоритмов>>}\newline\newline\newline
		\end{minipage}
	\end{center}

	\noindent\textbf{Тема} 			$\underline{\text{Алгоритмы поиска элемента в массиве}}$\newline\newline
	\noindent\textbf{Студент} 		$\underline{\text{Куликов Е. А.}}$\newline\newline
	\noindent\textbf{Группа} 		$\underline{\text{ИУ7-56Б}}$\newline\newline
	\noindent\textbf{Преподаватель} $\underline{\text{Волкова Л. Л.}}$\newline

	\begin{center}
		\vfill
		Москва~---~\the\year
		~г.
	\end{center}
	\restoregeometry
\end{titlepage}

\renewcommand{\contentsname}{СОДЕРЖАНИЕ}
\tableofcontents
\setcounter{page}{2}

% Введение
\chapter*{ВВЕДЕНИЕ}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}

В данной рабораторной работе изучаются алгоритмы поиска в массиве.
Поиск --- одна из базовых операций, производимых с массивами. Под поиском в массиве обычно понимают задачу нахождения индекса, по которому в массиве располагается некоторый элемент.
\parЦелью данной лабораторной работы является изучение и реализация различных алгоритмов поиска, таких как поиск полным перебором и бинарный поиск.
Для достижения поставленной цели необходимо решить следующие задачи:

\begin{itemize}
	\item[---] изучить алгоритм поиска полным перебором и алгоритм бинарного поиска в массиве;
	\item[---] реализовать указанные алгоритмы;
	\item[---] провести сравнение эффективности данных алгоритмов по количеству проверок элементов;
        \item[---] описать и обосновать полученные результаты в отчете о выполненной лабораторной работе.
\end{itemize}


\chapter{Аналитическая часть}

В данном разделе будут рассмотрены алгоритмы поиска в массиве.

\section{Алгоритм поиска полным перебором}
Если нет никакой дополнительной информации о способе хранения данных, то вероятнее всего данные расположены в произвольном порядке. В этом случае очевидный подход – простой последовательный просмотр массива или алгоритм полного перебора [1].
Для данной задачи алгоритм полного перебора заключается в проходе по массиву до тех пор, пока не будет найден указанный элемент или не закончится массив, что будет означать отсутствие указанного элемента в массиве.

\section{Алгоритм бинарного поиска}
Если поиск выполняется многократно и/или массив состоит из большого числа записей, то эффективней предварительно упорядочить этот массив (т.е. необходимо некоторым образом организовать
данные) [1].
Для этого можно использовать один из алгоритмов сортировки.

Идея алгоритма:
\begin{itemize}
	\item[---] Вводятся две переменные, обозначающие индексы левой и правой границ поиска в массиве;
	\item[---] Определяется значение в середине заданной зоны поиска;
	\item[---] Если это значение больше, чем искомое, поиск продолжается в первой половине зоны поиска (правая граница смещается к центральному элементу), иначе поиск продолжается во второй половине зоны поиска (левая граница смещается к центральному элементу);
	\item[---] Процесс продолжается до тех пор, пока не будет найден искомый элемент или не станет пустой зона поиска.
\end{itemize}

\section{Оценки трудоемкости алгоритмов}
Дадим оценку трудоемкости алгоритмов в терминах числа сравнений, которые понадобятся для нахождения ответа.
\subsection{Алгоритм поиска полным перебором}
\parДля алгоритма полного перебора число сравнений равно:
\begin{equation}
	\label{eq:L}
	N = \begin{cases}
	i + 1, &\text{i - индекс эл-та в массиве}\\
	N, &\text{если эл-та нет в массиве}\\
	\end{cases}
\end{equation}
\parПоэтому лучший случай --- 1 сравнение, когда искомый элемен является первым в массиве. Худший случай --- $N$ сравнений, когда искомый элемент является последним в массиве или когда искомый элемент в массиве отсутствует.
\par Алгоритмическая сложность данного алгоритма зависит от положения элемента в массиве, чем больше индекс элемента, тем больше проверок придется совершить. В общем случае алгоритм имеет сложность $O(n)$.
\subsection{Алгоритм бинарного поиска}
\parДля алгоритма бинарного поиска количество сравнений растет в зависимости от <<нечетности>> положения элемента. Например, для центрального элемента массива (расположенного по индексу $N // 2$) будет проведена 2 проверки (считаем и проверку на равенство, и проверку на больше/меньше). В два раза больше проверок будет проведено для элементов, расположенных по индексам кратным $N // 4$ --- $N // 4$, $3N // 4$. И так далее. Примерное правило: для элемента будет проведено $2 \cdot k$ проверок, если индекс этого элемента равен $N // (2 ^ {k})$.
\par Поэтому лучший случай для этого алгоритма --- 2 проверки, когда искомый элемент находится посередине массива. Худший случай --- $2 \cdot log_2(N)$ проверок, когда индекс элемента кратен $log_2(N)$.
\parДля заранее упорядоченного массива алгоритмическая сложность поиска случайного элемента равна $O(log(n))$, что лучше чем $O(n)$ у алгоритма поиска полным перебором. Однако если исходные данные не были изначально отсортированными, затраты на сортировку могут нивелировать это преимущество.

\section*{Вывод}
В данном разделе были рассмотрены алгоритмы поиска в массиве.


\chapter{Конструкторская часть}
В данном разделе будут разработаны алгоритм бинарного поиска и алгоритм поиска полным перебором .

\section{Разработка алгоритмов}

На вход каждому алгоритму подается массив целых чисел, его размер и искомый элемент.

На рис. \ref{fig:full} --- \ref{fig:bin} приведены алгоритмы поиска полным перебором и бинарного поиска.

\clearpage

\begin{figure}[h]
	\centering
 \vspace{0pt}
	\includegraphics[scale=0.8]{img/full.png}
	\caption{Алгоритм поиска полным перебором}
	\label{fig:full}
\end{figure}

\clearpage

\begin{figure}[h]
	\centering
        \vspace{0pt}
	\includegraphics[scale=0.8]{img/binary.png}
	\caption{Алгоритм бинарного поиска}
        \vspace*{3in}
	\label{fig:bin}
\end{figure}
\clearpage

\section*{Вывод}
В данном разделе были разработаны алгоритмы поиска полным перебором и бинарного поиска.

\clearpage

\chapter{Технологическая часть}

В данном разделе будут приведены данные о выбранном языке программирования, коды алгоритмов и тесты для каждого алгоритма.

\section{Требования к ПО}
Реализуемое ПО будет давать возможность ввести размер массива $n$, по которому будет сгенерирован массив из чисел от 0 до $n$, распределенных случайно, ввести искомый элемент. На выходе пользователь получает индекс найденного элемента или -1, если элемент не найден, а также количество проверок, проведенных во время работы каждого алгоритма.

\section{Язык программирования}
В данной работе для реализации алгоритмов был выбран язык программирования $Python$ [2]. Язык предоставляет возможность работы с массивами различной длины, а также возможность создания пользовательского интерфейса.

\section{Реализация алгоритмов}

В листингах \ref{lst:full} --- \ref{lst:bin} представлены реализации алгоритма поиска полным перебором и алгоритма бинарного поиска.

\clearpage

\begin{center}
\captionsetup{justification=raggedright,singlelinecheck=off}
\begin{lstlisting}[label=lst:full,caption=Реализация алгоритма поиска полным перебором]
def full_search(array: list[int], elem: int) -> (int, int):
    checks = 0
    for i in range(len(array)):
        checks += 1
        if array[i] == elem:
            return i, checks
    return -1, checks
\end{lstlisting}
\end{center}

\begin{center}
\captionsetup{justification=raggedright,singlelinecheck=off}
\begin{lstlisting}[label=lst:bin,caption=Реализация алгоритма бинарного поиска в массиве]
def binary_search(array: list[int], elem: int) -> (int, int):
    array.sort()
    left_border = 0
    right_border = len(array) - 1
    checks = 0
    while left_border <= right_border:
        checks += 2
        mid = (left_border + right_border) // 2
        if array[mid] == elem:
            return mid, checks
        elif array[mid] >= elem:
            right_border = mid - 1
        else:
            left_border = mid + 1
    return -1, checks
\end{lstlisting}
\end{center}

\clearpage

\section{Функциональные тесты}
В листинге \ref{lst:test} описан вывод программы для различных функциональных тестов. Все тесты программа прошла успешно.
\begin{center}
\captionsetup{justification=raggedright,singlelinecheck=off}
\begin{lstlisting}[label=lst:test,caption=Функциональные тесты]
Enter the size of the array: 10
Your array:  [1, 5, 4, 0, 3, 6, 7, 9, 2, 8]
Enter element: 4
FULL SEARCH index found: 2, checks: 3
BINARY SEARCH index found: 2, checks: 2

Enter the size of the array: 10
Your array:  [5, 0, 6, 9, 4, 2, 8, 7, 1, 3]
Enter element: 5
FULL SEARCH index found: 0, checks: 1
BINARY SEARCH index found: 0, checks: 6

Enter the size of the array: 10
Your array:  [3, 5, 6, 8, 7, 1, 2, 0, 4, 9]
Enter element: -1
FULL SEARCH index not found, checks: 10
BINARY SEARCH index not found, checks: 6
\end{lstlisting}
\end{center}

\section*{Вывод}
В данном разделе были приведены коды реализаций алгоритмов поиска, а также функциональные тесты.



\chapter{Исследовательская часть}
В данном разделе будут представлены результаты исследования эффективности работы алгоритмов по количеству проведенных проверок. При этом не учитывается проводимая предварительная сортировка входного массива для алгоритма бинарного поиска.

\section{Замеры количества проверок}

Результаты замеров количества произведенных проверок от позиции искомого элемента массива представлены на графиках \ref{fig:full_plot} --- \ref{fig:bin_sorted_plot}.
Замеры производились на массиве длины 1086 в соответствии с вариантом задания.
\parНа рисунке \ref{fig:full_plot} приведены замеры количества проведенных проверок от индекса искомого элемента для алгоритма поиска полным перебором, в том числе и для элемента, которого нет в массиве (ему соответствует левый высокий столбик графика)
\parНа рисунке \ref{fig:bin_plot} приведены аналогичные замеры для алгоритма бинарного поиска
\parНа рисунке \ref{fig:bin_sorted_plot} приведен отсортированный по количеству проверок график для алгоритма бинарного поиска для визуально более простого сравнения его с графиком поиска полным перебором.


\begin{figure}[t!]
	\centering
        \vspace{0pt}
	\includesvg[width=1.0\columnwidth]{img/Полный перебор.svg}
        %\includegraphics[scale=0.7]{img/Полный перебор.png}
	\caption{График количества проверок для поиска полным перебором i-го элемента от i}
        \vspace*{3in}
	\label{fig:full_plot}
\end{figure}

\begin{figure}[t!]
	\centering
        \vspace{0pt}
	\includesvg[width=1.0\columnwidth]{img/Бинарный поиск.svg}
        %\includegraphics[scale=0.7]{img/Бинарный поиск.png}
	\caption{График количества проверок для бинарного поиска i-го элемента от i}
        \vspace*{3in}
	\label{fig:bin_plot}
\end{figure}

\clearpage
\begin{figure}[t!]
	\centering
        \vspace{0pt}
	\includesvg[width=1.0\columnwidth]{img/Бинарный поиск с сортировкой.svg}
        %\includegraphics[scale=0.7]{img/Бинарный поиск с сортировкой.png}
	\caption{Отсортированный по количеству проверок график для поиска полным перебором}
        \vspace*{3in}
	\label{fig:bin_sorted_plot}
\end{figure}

\clearpage

\section*{Вывод}
Алгоритм бинарного поиска производит в среднем существенно меньше проверок, чем алгоритм поиска полным перебором. На графике \ref{fig:full_plot} видно, что в среднем для случайного элемента массива было произведено $1086 / 2 = 543$ проверки, в то время как для бинарного поиска было произведено максимум 22 проверки (см график \ref{fig:bin_plot}). Однако на графике не учтено, что перед бинарным поиском массив был отсортирован, то есть преимущество в количестве проверок могло быть нивелировано необходимостью сортировки массива.
\parТакже, из графиков \ref{fig:full_plot} и \ref{fig:bin_plot} видно, что в алгоритма поиска полным перебором количество проверок растет линейно от позиции искомого элемента, в то время как для алгоритма бинарного поиска количество проверок для каждого элемента зависит от его положения в массиве: чем ближе элемент расположен к индексу, равному степени двойки, и чем меньше эта степень, тем быстрее элемент будет найден. Так, меньше всего проверок нужно для элемента, расположенного посередине, на две проверки больше для элементов, расположенных в четвертях и так далее. Это также объясняет увеличение ширины столбцов одинаковой высоты ровно в 2 раза на графике \ref{fig:bin_sorted_plot} --- каждый столбец содержит количество проверок для $n - 1$ элементов, расположенных в $1 / 2^{n}$ частях исходного массива.

\chapter*{ЗАКЛЮЧЕНИЕ}
\addcontentsline{toc}{chapter}{ЗАКЛЮЧЕНИЕ}

В ходе выполнения данной лабораторной работы были изучены алгоритмы бинарного поиска и поиска полным перебором, а также решены следующие задачи:
\begin{itemize}
	\item[---] изучены алгоритм поиска полным перебором и алгоритм бинарного поиска в массиве;
	\item[---] реализованы указанные алгоритмы;
	\item[---] проведено сравнение эффективности данных алгоритмов по количеству проверок элементов;
        \item[---] описаны и обоснованы полученные результаты в отчете о выполненной лабораторной работе.
\end{itemize}

Алгоритм бинарного поиска производит в среднем существенно меньше проверок, чем алгоритм поиска полным перебором. На графике \ref{fig:full_plot} видно, что в среднем для случайного элемента массива было произведено $1086 / 2 = 543$ проверки, в то время как для бинарного поиска было произведено максимум 22 проверки (см график \ref{fig:bin_plot}). Однако на графике не учтено, что перед бинарным поиском массив был отсортирован, то есть преимущество в количестве проверок могло быть нивелировано необходимостью сортировки массива.
\parТакже, из графиков \ref{fig:full_plot} и \ref{fig:bin_plot} видно, что в алгоритма поиска полным перебором количество проверок растет линейно от позиции искомого элемента, в то время как для алгоритма бинарного поиска количество проверок для каждого элемента зависит от его положения в массиве: чем ближе элемент расположен к индексу, равному степени двойки, и чем меньше эта степень, тем быстрее элемент будет найден. Так, меньше всего проверок нужно для элемента, расположенного посередине, на две проверки больше для элементов, расположенных в четвертях и так далее. Это также объясняет увеличение ширины столбцов одинаковой высоты ровно в 2 раза на графике \ref{fig:bin_sorted_plot} --- каждый столбец содержит количество проверок для $n - 1$ элементов, расположенных в $1 / 2^{n}$ частях исходного массива.
\parПоставленная цель достигнута, все задачи решены.

\vspace{5mm}

\renewcommand{\bibname}{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
\begin{thebibliography}{5}
        \bibitem{bib2}
	Самуйлов, Сергей Владимирович.
Структуры и алгоритмы обработки данных : учеб. пособие / С. В. Самуйлов, С. В. Самуйлова, Л. В. Гурьянов. –-
Пенза : Изд-во ПГУ, 2023. – 80 с.
	\bibitem{bib2}
	Документация языка Welcome to Python [Электронный ресурс]. Режим доступа: \url{https://www.python.org} (дата обращения: 30.09.2024).
\end{thebibliography}

\addcontentsline{toc}{chapter}{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}

\end{document}

